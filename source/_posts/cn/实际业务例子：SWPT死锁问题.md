---
layout: post
title: 实际业务例子：SWPT死锁问题
catalog: true
typora-root-url: 实际业务例子：SWPT死锁问题
author: Futari
date: 2023-12-26 22:16:14
---

首先明确一点，SpringBoot中的隐式事务，都是在执行sql（如mapper）时创建的，属于既定规范。

_**方法级别管理事务（原子性）**_

> 另外有一些不熟悉的，如果sql调用触发器、使用消息队列， JTA（Java Transaction API）分布式事务  等会新开事务

默认当方法正常执行完毕时，事务会自动提交并且关闭事务，但是有时候通过DEBUG时SQL查询发现事务仍存在，未被提交，还需要继续研究。





再明确一点，RPC调用其他的微服务，被调用方的数据库操作是在被调用方开启的事务，不属于当前服务的事务管理器管理范围，即不处于同一个事务边界内。



调用RPC是阻塞的，所以方法内开启事务再调用RPC，需要等待被调方事务提交之后，本地事务再提交

所以不属于任何事务嵌套机制，不在同一管理范围内。





自测使用 PlatformTransactionManager  手动commit，但是事务没有被提交，不知道为什么？可能是初始化initstacktrace出现错误信息，即事务初始化参数错误？



目前解决方式：

1.去除冲突的业务逻辑，使用别的方式，避免被调用方新开事务，直接统一在本地事务解决操作或在被调方统一解决。

2.修改业务逻辑，将发生行锁，表锁的逻辑合并到同一服务（事务边界）内，避免多服务事务发生死锁。

