---
layout: post
title: '企业开发中遇到的常用注解'
date: 2022-07-07
author: Futari
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: 注解
---



#### @Builder实现建造者模式

##### [建造者模式](https://so.csdn.net/so/search?q=建造者模式&spm=1001.2101.3001.7020)。简单来说，就是一步步创建一个对象，它对用户屏蔽了里面构建的细节，但却可以精细地控制对象的构造过程，而不是一次性的完成对象构建。

###### 这个注解提供了一种优雅的编程方式，用来创建对象，原理上通过以下来实现

###### （Ps：父类的属性不能产于builder）

```java
@Builder
public class Demo {
    private final int finalVal = 10;

    private String name;
    private int age;
}

```

经过编译之后的字节码：

```java
public class Demo {
    private final int finalVal = 10;
    private String name;
    private int age;

    Demo(String name, int age) {
        this.name = name;
        this.age = age;
    }
	//生成了一个静态的builder()和一个静态内部类
    public static Demo.DemoBuilder builder() {
        return new Demo.DemoBuilder();
    }

    public static class DemoBuilder {
        private String name;
        private int age;

        DemoBuilder() {
        }

        public Demo.DemoBuilder name(String name) {
            this.name = name;
            return this;
        }

        public Demo.DemoBuilder age(int age) {
            this.age = age;
            return this;
        }

        public Demo build() {
            return new Demo(this.name, this.age);
        }

        public String toString() {
            String var10000 = this.name;
            return this.age;
        }
    }
}

```

因此我们构造一个对象就可以优雅的这么来：

```java
 public static void main(String[] args) {
     	//不用写内部类的类名，直接外部类就能调
        Demo demo = Demo.builder().name("aa").age(10).build();
        System.out.println(demo); 
    }
```


里面有一些自定义参数，我表示，完全没有必要去自定义。直接调用@Builder.Default用默认

#### @WebFilter配置Servlet过滤器（不是拦截器，两者不同）

先搞清楚两者的区别，拦截器是实现接口之后并添加到拦截器集合中才会生效，Interceptor是Aop的一种实现方式，在访问前或者访问后加入某些操作，也就是实现了解耦合。
