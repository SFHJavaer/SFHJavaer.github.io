---
layout: post
title: 'Java IO流笔记'
date: 2021-07-31
author: Futari
cover: 'http://on2171g4d.bkt.clouddn.com/jekyll-banner.png'
tags: Java
---

## Java IO流

英文字母在windows中占1个字节   比如：'a'字符

中文汉字在windows中占2个字节   比如：“中”字符

字节流一次读取一个字节

字符流一次读取一个字符



IO流四大家族的首领：

##### java.io.InputStream				字节输入流

##### java.io.OutputStream				字节输出流

##### java.io.Reader 				字符输入流

##### java.io.Writer					字符输出流



**注意：在Java中只要类名以Stream结尾的都是字节流，以Reader或者Writer结尾的都是字符流**

**所有的流都实现了Java.io.Closeable接口，都是可关闭的，都有close方法，流是一个管道，用完之后一定要关闭**

**flush（）是刷新方法，输出流实现了它（java.io.flush接口），输入流没有实现（注意硬盘上的文件读取到内存到读（内存读）），所以用完输出流之后也要刷新一下，刷新表示将未输出的数据强行输出完（清空管道）**



需要掌握的几个主要的流：文件专属流		转换流		数据流		标准输出流		对象专属流

下面的展示了FileInputStream读取文件的基本代码：

```java
package com.java.io;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

//读和写是把内存作为主体
//路径：/ 代表的路径是根目录；. 代表的路径是当前Java项目的根目录,idea默认相对路径也是从工程的根目录开始。所以开头直接可以指定到src
public class FileInputStreamText {
    public static void main(String[] args) {
        FileInputStream file = null;
        //创建文件字节输入流,main方法异常一般直接try catch
        try {
            file = new FileInputStream("src/com/java/io/File.txt");





//方法一：下面的read方法只能读取单字节，可以利用自建一个byte数组来读取多个字节
            //            int readData = 0;
//            while((readData = file.read()) != -1){
//                System.out.println(readData);
//            }
            //方法二最终版
            byte[] bytes = new byte[4];
            int readCount = 0;
            while((readCount = file.read(bytes)) != -1){
                System.out.print(new String(bytes,0,readCount));
            }
//下面是方法二
//            while(true){
//                //读取一个数组返回的是一次读取字节的数量，而不是字节值
//                int readCount = file.read(bytes);
//                if(readCount == -1){
//                    break;
//                }
//                //把读到的readCount个数据打印出来，因为用数组存储字节，对第上一轮数据没有覆盖的话，数组中未被覆盖的字节还会保留。
//                System.out.print(new String(bytes,0,readCount));
//            }





        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            //在finally中关闭流,关闭流的前提是 流不是空，避免空指针异常
            if (file != null){
                try {
                    file.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }
}
```













