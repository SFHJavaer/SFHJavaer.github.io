<!DOCTYPE html>
<html lang="en">

<!-- Head tag (contains Google-Analytics、Baidu-Tongji)-->
<head>
  <!-- Google Analytics -->
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="async" src="https://www.googletagmanager.com/gtag/js?id=UA-xxxxxx-xx"></script>
    <script type="text/javascript">
      window.dataLayer = window.dataLayer || [];

      function gtag() {
        dataLayer.push(arguments);
      }
      gtag('js', new Date());

      gtag('config', 'UA-xxxxxx-xx');
    </script>
  

  <!-- Baidu Tongji -->
  
    <script type="text/javascript">
      // Originial
      var _hmt = _hmt || [];
      (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
      })();
    </script>
  

  <!-- Baidu Push -->
  
    <script>
      (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
          bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
          bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
      })();
    </script>
  

  <meta charset="utf-8"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <meta name="google-site-verification" content="lxDfCplOZbIzjhG34NuQBgu2gdyRlAtMB4utP5AgEBc"/>
  <meta name="baidu-site-verification" content="PpzM9WxOJU"/>

  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="description" content="It&#39;s an IT blog..."/>
  <meta name="keyword" content="java,Futari,livemylife,IT  blog,Blog"/>
  <link rel="shortcut icon" href="/img/avatar/roguerabbit.jpg"/>

  <!-- Place this tag in your head or just before your close body tag. -->
  <script async="async" defer="defer" src="https://buttons.github.io/buttons.js"></script>

  
    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/bootstrap.min.css"/>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/beantech.min.css"/>

    <!-- Pygments Highlight CSS -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/highlight.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/widget.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/rocket.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/signature.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/catalog.css"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/livemylife.css"/>

    
      <!-- wave start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/wave.css"/>
      <!-- wave end -->
    

    
      <!-- top start (article top hot config) -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/top.css"/>
      <!-- top end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/scroll.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- viewer start (Picture preview) -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/viewer.min.css"/>
      <!-- viewer end -->
    

    
      <!-- Search start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/search.css"/>
      <!-- Search end -->
    

    
      <!-- ThemeColor start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/css/themecolor.css"/>
      <!-- ThemeColor end -->
    

    
      <!-- gitment start -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/default.css"/>
      <!-- gitment end -->
    

    

  

  <!-- Custom Fonts -->
  <!-- <link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css" rel="stylesheet" type="text/css"> -->
  <!-- Hux change font-awesome CDN to qiniu -->
  <link rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/4.5.0/css/font-awesome.min.css" type="text/css">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">

  <!-- Hux Delete, sad but pending in China <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'> <link
  href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/ css'> -->

  <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
  <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
  <!--[if lt IE 9]> <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script> <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script> <![endif]-->

  <!-- ga & ba script hoook -->
  <link rel="canonical" href="http://example.com/cn/近期对多线程的深入理解/">
  <title>
    
      近期对多线程的深入理解 - 一入Java深似海
    
  </title>
<meta name="generator" content="Hexo 5.4.0"></head>


<!-- hack iOS CSS :active style -->

	<body ontouchstart="" class="body--light body--dark">


		<!-- ThemeColor -->
		
		<!-- ThemeColor -->
<style type="text/css">
  .body--light {
    --light-mode: none;
    --dark-mode: block;
  }
  .body--dark {
    --light-mode: block;
    --dark-mode: none;
  }
  i.mdui-icon.material-icons.light-mode {
    display: var(--light-mode);
  }
  i.mdui-icon.material-icons.dark-mode {
    display: var(--dark-mode);
  }
</style>
<div class="toggle" onclick="document.body.classList.toggle('body--dark')">
  <i class="mdui-icon material-icons light-mode"></i>
  <i class="mdui-icon material-icons dark-mode"></i>
</div>
<script>
  //getCookieValue
  function getCookieValue(a) {
    var b = document.cookie.match('(^|[^;]+)\\s*' + a + '\\s*=\\s*([^;]+)');
    return b
      ? b.pop()
      : '';
  }
  let themeMode = 'dark';
  if (getCookieValue('sb-color-mode') && (getCookieValue('sb-color-mode') !== themeMode)) {
    let dbody = document.body.classList;
    themeMode === 'dark' ? dbody.remove('body--dark') : dbody.add('body--dark');
  }

  //setCookieValue
  var toggleBtn = document.querySelector(".toggle");
  toggleBtn.addEventListener("click", function () {
    var e = document.body.classList.contains("body--dark");
    var cookieString = e
      ? "dark"
      : "light";
    var exp = new Date();
    exp.setTime(exp.getTime() + 3 * 24 * 60 * 60 * 1000); //3天过期
    document.cookie = "sb-color-mode=" + cookieString + ";expires=" + exp.toGMTString() + ";path=/";
  });
</script>

		

		<!-- Gitter -->
		
		<!-- Gitter -->
<!-- Docs:https://gitter.im/?utm_source=left-menu-logo -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'your-community/your-room'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

		

		<!-- Navigation (contains search)-->
		<!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header page-scroll">
      <button type="button" class="navbar-toggle">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/">Live My Life</a>
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <!-- Known Issue, found by Hux: <nav>'s height woule be hold on by its content. so, when navbar scale out, the <nav> will cover tags. also mask any touch event of tags, unfortunately. -->
    <div id="huxblog_navbar">
      <div class="navbar-collapse">
        <ul class="nav navbar-nav navbar-right">
          <li>
            <a href="/">首页</a>
          </li>

          
          
          
          
          <li>
            <a href="/archive/">
              
              归档
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/categories/">
              
              分类
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/about/">
              
              关于
              
              
            </a>
          </li>
          
          
          
          <li>
            <a href="/tags/">
              
              标签
              
              
            </a>
          </li>
          
          

          
          <li>
            <a class="popup-trigger">
              <span class="search-icon"></span>搜索</a>
          </li>
          

          <!-- LangSelect -->
          
          
          
          
          
        </ul>
      </div>
    </div>
    <!-- /.navbar-collapse -->
  </div>
  <!-- /.container -->
</nav>
<!-- progress -->
<div id="progress">
  <div class="line" style="width: 0%;"></div>
</div>

<script>
  // Drop Bootstarp low-performance Navbar Use customize navbar with high-quality material design animation in high-perf jank-free CSS3 implementation
  var $body = document.body;
  var $toggle = document.querySelector('.navbar-toggle');
  var $navbar = document.querySelector('#huxblog_navbar');
  var $collapse = document.querySelector('.navbar-collapse');

  $toggle.addEventListener('click', handleMagic)

  function handleMagic(e) {
    if ($navbar.className.indexOf('in') > 0) {
      // CLOSE
      $navbar.className = " ";
      // wait until animation end.
      setTimeout(function() {
        // prevent frequently toggle
        if ($navbar.className.indexOf('in') < 0) {
          $collapse.style.height = "0px"
        }
      }, 400)
    } else {
      // OPEN
      $collapse.style.height = "auto"
      $navbar.className += " in";
    }
  }
</script>


		<!-- Post Header (contains intro-header、signature、wordcount、busuanzi、waveoverlay) -->
		<!-- Modified by Yu-Hsuan Yen -->
<!-- Post Header -->

  <!-- CDN: jsdelivr start -->
  <style type="text/css">
    .body--light {
      /* intro-header */
      --intro-header-background-image-url-home: url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/img/header_img/lml_bg.jpg');
      --intro-header-background-image-url-page: url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io//img/header_img/lml_bg.jpg');
    }
    .body--dark {
      --intro-header-background-image-url-home: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/img/header_img/newhome_bg.jpg');
      --intro-header-background-image-url-post: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/img/header_img/lml_bg.jpg');
      --intro-header-background-image-url-page: linear-gradient(rgba(0, 0, 0, 0.1), rgba(0, 0, 0, 0.2)), url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io//img/header_img/lml_bg.jpg');
    }
    header.intro-header {
       /*post*/
        background-image: var(--intro-header-background-image-url-post);
        /* background-image: url('https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/img/header_img/lml_bg.jpg'); */
      
    }

    
      #signature {/*signature*/
        background-image: url('/img/signature/vincent-white.png');
      }
    
  </style>
  <!-- CDN: jsdelivr end -->





<header class="intro-header">
  <!-- Signature -->
  <div id="signature">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
          
          <div class="post-heading">
            <div class="tags">
              
              <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
              
            </div>
            <h1>近期对多线程的深入理解</h1>
            <h2 class="subheading">近期对多线程的深入理解</h2>
            <span class="meta">
              Posted by SFHJavaer on
              2020-08-19
            </span>


            
            <!-- WordCount start -->
            <div class="blank_box"></div>
            <span class="meta">
              Estimated Reading Time <span class="post-count">17</span> Minutes
            </span>
            <div class="blank_box"></div>
            <span class="meta">
              Words <span class="post-count">4.6k</span> In Total
            </span>
            <div class="blank_box"></div>
            <!-- WordCount end -->
            
            
            <!-- 不蒜子统计 start -->
            <span class="meta" id="busuanzi_container_page_pv">
              Viewed <span id="busuanzi_value_page_pv"><i class="fa fa-spinner fa-spin"></i></span> Times
            </span>
            <!-- 不蒜子统计 end -->
            


          </div>
          
        </div>
      </div>
    </div>
  </div>

  
  <!-- waveoverlay start -->
  <div class="preview-overlay">
    <svg class="preview-waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
      <defs>
        <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"></path>
      </defs>
      <g class="preview-parallax">
        <use xlink:href="#gentle-wave" x="48" y="0" fill=var(--gentle-wave1)></use>
        <use xlink:href="#gentle-wave" x="48" y="3" fill=var(--gentle-wave2)></use>
        <use xlink:href="#gentle-wave" x="48" y="5" fill=var(--gentle-wave3)></use>
        <use xlink:href="#gentle-wave" x="48" y="7" fill=var(--gentle-wave)></use>
      </g>
    </svg>
  </div>
  <!-- waveoverlay end -->
  

</header>



		<!-- Main Content (Post contains
	Pager、
	tip、
	socialshare、
	gitalk、gitment、disqus-comment、
	Catalog、
	Sidebar、
	Featured-Tags、
	Friends Blog、
	anchorjs、
	) -->
		<!-- Modify by Yu-Hsuan Yen -->
<!-- Post Content -->
<article>
  <div class="container">
    <div class="row">
      <!-- Post Container -->
      <div class="col-lg-8 col-lg-offset-1 col-md-10 col-md-offset-1 post-container">

        <h6 id="最近重新深入多线程中的细节问题进行了深入，在死锁、终止线程、Guava、线程池以及队列又有了深入的思考。">最近重新深入多线程中的细节问题进行了深入，在死锁、终止线程、Guava、线程池以及队列又有了深入的思考。</h6>
<blockquote>
<p>在线程的生命周期中，我们常说的其实就五个状态，其中阻塞态包括了sleep以及wait都可以当作处于阻塞态，当然两种方法产生的效果当然是不同的</p>
</blockquote>
<h4 id="对阻塞态即blocked状态进行细分：">对阻塞态即blocked状态进行细分：</h4>
<p>等待阻塞：wait()方法调用，这种属于主动调用</p>
<p>同步阻塞：线程在获取synchronized锁时没拿到，会进入同步阻塞状态</p>
<p>其他阻塞：使用sleep休眠或者join等待其他线程的执行、或者发出了IO请求</p>
<p>等待阻塞需要重新获取锁，同步阻塞是一种等待状态，而sleep不会释放锁，而join从原来上来看使用了wait方法，所以会释放锁，等待调用的线程对象执行完，currentThread才会继续执行</p>
<h6 id="而yield和阻塞状态无关，会直接进入到就绪状态等待CPU时间片的分配">而yield和阻塞状态无关，会直接进入到就绪状态等待CPU时间片的分配</h6>
<h4 id="join释放锁和可能产生的死锁问题详解">join释放锁和可能产生的死锁问题详解</h4>
<h4 id="产生死锁示例：">产生死锁示例：</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadJoinTestLock</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Object object = <span class="keyword">new</span> Object();</span><br><span class="line">		MThread mythread = <span class="keyword">new</span> MThread(<span class="string">&quot;mythread &quot;</span>, object);</span><br><span class="line">		mythread.start();</span><br><span class="line">		<span class="comment">//synchronized (mythread)</span></span><br><span class="line">		<span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;开始join&quot;</span>);</span><br><span class="line">						mythread.join();<span class="comment">//main主线程让出CPU执行权，让mythread子线程优先执行</span></span><br><span class="line">						System.out.println(<span class="string">&quot;结束join&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() +<span class="string">&quot;==&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">&quot;main方法执行完毕&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Object obj;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MThread</span><span class="params">(String name, Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.obj = obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (obj) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				System.out.println(name + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么会产生死锁？</p>
<p>因为obj已经被主线程锁了，另一个线程再去sync，当然获取不到了</p>
<p>如果将ThreadJoinTestLock的锁对象修改为线程对象mythread：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mythread) &#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">				<span class="keyword">if</span> (i == <span class="number">20</span>) &#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						System.out.println(<span class="string">&quot;开始join&quot;</span>);</span><br><span class="line">						mythread.join();<span class="comment">//main主线程让出CPU执行权，让mythread子线程优先执行</span></span><br><span class="line">						System.out.println(<span class="string">&quot;结束join&quot;</span>);</span><br><span class="line">					&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				System.out.println(Thread.currentThread().getName() +<span class="string">&quot;==&quot;</span> + i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h6 id="这样会把锁的线程对象进行释放，当然不会产生死锁了，重点在于搞清楚锁的到底是谁">这样会把锁的线程对象进行释放，当然不会产生死锁了，重点在于搞清楚锁的到底是谁</h6>
<h5 id="PS：但是join释放锁和wait释放锁是有区别的，wait需要重新抢占对象的锁，但是join等待调用线程执行完之后就可以继续执行了，原因就是join释放的不是调用的Object对象的锁，synchronized锁的一般是Object对象，而join源码中用的是this-wait，而join只能线程对象去调，所以释放的是thread1的锁">PS：但是join释放锁和wait释放锁是有区别的，wait需要重新抢占对象的锁，但是join等待调用线程执行完之后就可以继续执行了，原因就是join释放的不是调用的Object对象的锁，synchronized锁的一般是Object对象，而join源码中用的是this.wait，而join只能线程对象去调，所以释放的是thread1的锁</h5>
<h5 id="如下：">如下：</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    thread.join(); <span class="comment">//join不释放锁</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span>(thread)&#123;</span><br><span class="line">    thread.join(); <span class="comment">//join释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一个为什么不释放锁，因为锁的是Object对象，thread对象调的join，没得释放</p>
<p>第二个锁的是thread，所以会释放，所以另外的线程可以在thread.join时拿到锁，不会死锁</p>
<h4 id="Thread如何终止线程">Thread如何终止线程</h4>
<h6 id="1-正常情况下，当然等线程的run执行体执行完之后线程会自动终止">1.正常情况下，当然等线程的run执行体执行完之后线程会自动终止</h6>
<h6 id="2-stop-方法">2.stop()方法</h6>
<p>是一个不安全的方法，并且在新版本JDK中被deprecated</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">为什么弃用stop：</span><br><span class="line"></span><br><span class="line">调用 stop() 方法会立刻停止 run() 方法中剩余的全部工作，包括在 catch 或 finally 语句中的，并抛出ThreadDeath异常(通常情况下此异常不需要显示的捕获)，因此可能会导致一些清理性的工作的得不到完成，如文件，数据库等的关闭。</span><br><span class="line">调用 stop() 方法会立即释放该线程所持有的所有的锁，导致数据得不到同步，出现数据不一致的问题,比如对象赋值到一半线程终止了。</span><br></pre></td></tr></table></figure>
<h5 id="font-color-blue-PS：线程的管理方法-font"><font color = 'blue'>PS：线程的管理方法</font></h5>
<p>start()：启动线程并执行相应的run()方法</p>
<p>stop()：执行线程体</p>
<p>resume()：用于继续执行已经挂起的线程</p>
<p>suspend():用于挂起一个线程，当然是到一个安全点在挂起</p>
<p>destory()：用于销毁线程组及其所有子组。线程组必须为空，表示该线程组中的所有线程此后都已停止。，被弃用了</p>
<h6 id="3-比较安全的线程停止方式：中断，interrupt-，是非静态方法">3.比较安全的线程停止方式：中断，interrupt()，是非静态方法</h6>
<h6 id="属于主动式中断，也就是会设置一个标志位，线程会不断轮询标志位，当标志位为真时，会在最近的一个安全点挂起线程。">属于主动式中断，也就是会设置一个标志位，线程会不断轮询标志位，当标志位为真时，会在最近的一个安全点挂起线程。</h6>
<p>可以先获取当前线程再调：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().interrupt()</span><br></pre></td></tr></table></figure>
<p>调用interrput会抛出InterruptedException异常，要进行捕获或抛出</p>
<h6 id="需要明确的一点的是：interrupt-方法并不像在-for-循环语句中使用-break-语句那样干脆，马上就停止循环。调用-interrupt-方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。">需要明确的一点的是：interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</h6>
<p>线程中断并不会立即终止线程，而是通知目标线程，有人希望你终止。至于目标线程收到通知后会如何处理，则完全由目标线程自行决定。这一点很重要，如果中断后，线程立即无条件退出，那么我们又会遇到 stop() 方法的老问题。所以可以理解成线程会执行到一个安全点再停止。</p>
<blockquote>
<p>在项目中遇到了这个问题，下面是代码中的注释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里为什么使用stop，官方弃用是因为安全问题，这里没有安全问题且由于readLine()的缘故，无法使用interrupt标志</span></span><br><span class="line">thread.stop();</span><br></pre></td></tr></table></figure>
<p>我是这样理解的，因为测试任务已经执行完了，这里使用了readLine来读取执行结果，如果出现设备未连接就调用这个方法的情况（因该方法传入的参数是InputStream，然后用readBuffer读的），导致inputstream阻塞，所以也没有将inputstream关闭，直接把测试线程中断了（在设备未连接的情况线程没有必要继续执行）</p>
<blockquote>
<p>为什么不用interrupt()?</p>
<p>原因是：interrupt会中断阻塞抛一个异常并设置标志位，而不是直接中断线程。如果线程没阻塞就会继续执行，阻塞了就会被打断，接着继续执行线程，不能达到中断任务的目的。所以说我们在使用interrupt时一般是和一个标志位进行配合:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(thread.isInterrupt()&amp;&amp;flag)&#123;<span class="comment">//中断线程操作，flag是全局的&#125;</span></span><br></pre></td></tr></table></figure>
<p>也可以用for循环来控制线程的执行,用for循环的继续执行条件来完成终止操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(</span><br><span class="line">    () -&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        Thread thread = Thread.currentThread();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span> &amp;&amp; !thread.isInterrupted(); i++) &#123;</span><br><span class="line">            LOGGER.info(<span class="string">&quot;线程&quot;</span> + thread.getName() + <span class="string">&quot;i=&quot;</span> + i + <span class="string">&quot;isInterrupted=&quot;</span> + thread.isInterrupted());</span><br><span class="line">            ;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                thread.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOGGER.info(<span class="string">&quot;线程&quot;</span> + thread.getName() + <span class="string">&quot;停止运行&quot;</span> + <span class="string">&quot;isInterrupted=&quot;</span> + thread.isInterrupted());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">				</span><br><span class="line">				).start();</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h5 id="为什么推荐用自己的定义的全局flag去判断？">为什么推荐用自己的定义的全局flag去判断？</h5>
<h6 id="原因是自己定义的范围更广，而判断线程自带的标志位比较麻烦要调方法，flag也可以应用到中断阻塞线程上，如main线程调用thread01-interrupt-，而thread01的run中一直是sleep的，sleep是不能判断falg的，thread01依靠判断标志位来决定是不是停止自己，所以掉了interrupt之后，抛了Exception就会强行中断sleep，所以会到thread01的catch中判断标志位，然后标志位是true，就可以放心中断自己了。可以用isInterrupted去判断是不是被中断了，原理是通过检查是否有标志位的设置，如果自己不设置标志位的话，就用isInterrupted判断标志位是不是true，注意这个interrupt-第一次执行会把标志位变为true，再次调用的话就变成false了。">原因是自己定义的范围更广，而判断线程自带的标志位比较麻烦要调方法，flag也可以应用到中断阻塞线程上，如main线程调用thread01.interrupt()，而thread01的run中一直是sleep的，sleep是不能判断falg的，thread01依靠判断标志位来决定是不是停止自己，所以掉了interrupt之后，抛了Exception就会强行中断sleep，所以会到thread01的catch中判断标志位，然后标志位是true，就可以放心中断自己了。可以用isInterrupted去判断是不是被中断了，原理是通过检查是否有标志位的设置，如果自己不设置标志位的话，就用isInterrupted判断标志位是不是true，注意这个interrupt()第一次执行会把标志位变为true，再次调用的话就变成false了。</h6>
<h4 id="守护线程">守护线程</h4>
<p>守护线程是如果系统中只要有一个非守护线程在运行，那么守护线程就不会结束，所以在Java中将用户线程设置为守护线程之后，只有当main主线程结束之后，守护线程才会结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread01.setdaemon(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="关于Guava中的多线程">关于Guava中的多线程</h4>
<p>除了语言本身与JDK在不断的进化，第三方库、框架也同样是日新月异。Guava正是这样一个现代的库，它简单易用，对Java语言是一个非常好的补充，原因是原本Java自身的缺陷以及使用诟病。</p>
<p>当然Apache也算是第三方的类库，就像python中的很多第三方一样。</p>
<p>比如初始化集合</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//JDK</span><br><span class="line">List&lt;String&gt; list = new ArrayList&lt;String&gt;(); </span><br><span class="line">list.add(&quot;a&quot;);</span><br><span class="line">list.add(&quot;b&quot;);</span><br><span class="line">list.add(&quot;c&quot;);</span><br><span class="line">list.add(&quot;d&quot;);</span><br><span class="line"></span><br><span class="line">//Guava</span><br><span class="line">List&lt;String&gt; list = Lists.newArrayList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;);</span><br></pre></td></tr></table></figure>
<h6 id="在多线程线程池中：池中的多个线程命名都是Thread-01等等由系统分批，如果我们有多个任务，每个任务有各自执行任务的线程池，那么在任务执行打印日志时，我们是无法分清楚执行线程是属于哪一个池的，当然在执行单个线程的时候，我们可以使用Thread-setName来指定线程的名称，但是在Java中没有提供一个可供修改线程中线程命名的方式。">在多线程线程池中：池中的多个线程命名都是Thread-01等等由系统分批，如果我们有多个任务，每个任务有各自执行任务的线程池，那么在任务执行打印日志时，我们是无法分清楚执行线程是属于哪一个池的，当然在执行单个线程的时候，我们可以使用<strong>Thread.setName</strong>来指定线程的名称，但是在Java中没有提供一个可供修改线程中线程命名的方式。</h6>
<p>我们先看看ThreadFactory（接口）的继承关系，可以看到实现类很多，我们一般情况如果没有多任务的需求的话就使用defaultThreadFactory即可。</p>
<p><img src="https://s2.loli.net/2022/07/25/Vq1XFh9uBNGx7Ef.png" alt="screenShot.png"></p>
<h5 id="所以Guava就提供了这么一种链式编程方式（其实看官方注解可以发现是建造者），可以修改线程组命名-位于gcuc包中：">所以Guava就提供了这么一种链式编程方式（其实看官方注解可以发现是建造者），可以修改线程组命名,位于gcuc包中：</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.google.common.util.concurrent.ThreadFactoryBuilder;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/07/25/a3tG2IpAwCRQTcX.png" alt="screenShot.png"></p>
<p>可以很清楚的看到我这里是新创建了一个线程池类，是为了解耦合，没有直接在业务实现类中new ThreadPoolExecutor，然后调用的super父类构造,下面解读下这个代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ThreadFactoryBuilder().setNameFormat(deviceId+<span class="string">&quot;-%d&quot;</span>).build());</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2022/07/25/uPXOvIgJ9KNCzbt.png" alt="Builder"></p>
<p>可以看到注解写的很清楚，某一任务的线程池的名称才是按照数字递增的，将不同池之间进行区分，</p>
<p>-%d代表从0开始递增。</p>
<h3 id="线程池问题">线程池问题</h3>
<h6 id="首先说下运算类型：CPU密集型、IO密集型">首先说下运算类型：CPU密集型、IO密集型</h6>
<p>都很好理解，前者是系统执行任务主要聚焦在CPU上，内存硬盘等硬件不是限制系统运行的瓶颈，内存等资源的占用率很低，而CPU常常处于100%，后者同理。</p>
<h5 id="一般如何设置线程池大小（核心线程数）？N代表CPU的核心数，正常还是一个核心一个线程">一般如何设置线程池大小（核心线程数）？N代表CPU的核心数，正常还是一个核心一个线程</h5>
<p>为什么设置线程池大小，原因是为了提升CPU使用率，理想情况我们想让CPU为100%，不会浪费Cpu资源，所以我们才分了上面两种情况</p>
<blockquote>
<p>对于计算密集型，系统任务主要都集中到运算上，所以CPU利用率很高，所以一般N+1即可，为什么不直接设置成N呢？</p>
<p>原因是计算密集型可能会因为某些原因暂停，比如页缺失，所以这个额外的线程会保证空出来的一个线程资源不会被浪费。比如复杂的算法</p>
</blockquote>
<blockquote>
<p>对于IO密集型，常常会发生IO阻塞，所以此时CPU处于闲置状态浪费资源，所以要更大的线程数</p>
<p>当然如果不是iO密集型，但是线程会常常阻塞，所以可以当作IO密集型来处理</p>
</blockquote>
<p>如果是IO密集型，那么线程池大小是2N+1，当然2N也是可以的，应用场景大多是IO密集型的，比如文件传输、数据库交互、网络数据传输。</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">当然还存在混合型任务，这样的话一般就是多线程池，将任务的操作进行划分，分为上面两种，然后分别处理。</span><br><span class="line">当然有注意点：</span><br><span class="line">如果划分完的两种任务执行的时间相差不大那就很好，会比串行的效率高很多（两个池的任务都执行完才代表原本的单线程一个完整任务的执行完毕）</span><br><span class="line">如果两种任务差距很大，那么先执行完的任务要等待剩下的一部分任务，总体时间取决于后执行额任务了，那么最后还要加上任务拆分和合并的时间，得不偿失。</span><br></pre></td></tr></table></figure>
<p>IO优化中，这样的估算公式可能更适合：</p>
<blockquote>
<p>最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CP U数目。</p>
</blockquote>
<p>因为很显然：<br>
（1）线程等待时间所占比例越高，需要越多线程。<br>
（2）线程CPU时间所占比例越高，需要越少线程。</p>
<h3 id="一个问题">一个问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？</span><br><span class="line">（<span class="number">1</span>）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+<span class="number">1</span>，减少线程上下文的切换</span><br><span class="line">（<span class="number">2</span>）并发不高、任务执行时间长的业务要区分开看：</span><br><span class="line">　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务</span><br><span class="line">　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（<span class="number">1</span>）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</span><br><span class="line">（<span class="number">3</span>）并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（<span class="number">2</span>）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。</span><br></pre></td></tr></table></figure>
<h5 id="你的项目中线程池主要用在这几个地方">你的项目中线程池主要用在这几个地方</h5>
<p><strong>1</strong>.下载app上，使用线程池下载，核心线程数为4，最大线程数8，线程工厂自己Builder</p>
<p>执行调用execute方法执行，这个方法在Executor顶层接口中定义，方法参数当然是线程体也就是Runnable，直接传入service方法到lambda中匿名Runable类作为参数即可。</p>
<p><strong>2.<strong>执行任务上，前面说了通过各种任务封装生成任务执行对象，这个对象是Runnable类型，那么直接把这个任务扔到</strong>任务线程池</strong>即可，这个任务线程池使用的是SynchronousQueue</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用了多线程的好处就是不是单线程的等待代码执行了，而是将任务执行依赖于责任链的任务进度。比如线程分配了download任务，线程池去下载然后下载完之后，各自的下载线程通知Observer，然后Observer完成相对应onNext();</span><br><span class="line">比如又调用了另一个任务线程池执行task。</span><br></pre></td></tr></table></figure>
<p>**项目线程池执行流程：**任务是运行态动态生成的，而我们的线程池的new是在bean的构造方法中执行的，也就是bean创建时就生成了线程池对象，我们后面直接接收到请求处理service扔进线程池就可以</p>
<h5 id="能不能改成普通队列呢？">能不能改成普通队列呢？</h5>
<p>当然可以，因为多个任务是互不干扰的，所以当然可以使用其他队列，就比如LinkedBlockingQueue，关键是设置好它的参数这里用SynchronousQueue只是保证了最基础的不会溢出，可以按需求自己设置，这里使用core = 1，max=2设置的很小，就是因为再开发环境测试时可能CPU太高，所以下载就直接N，这边执行直接取的1,max = 2</p>
<h3 id="SynchronousQueue">SynchronousQueue</h3>
<p>SynchronousQueue的目的就是保证“对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务”。联想一下线程池i执行流程，首先core = 1，任务进来直接执行，再进来进入到queue中，因为max  = 2，所以直接创建一个但是限制为2,就是为了避免newCacheThreadPool的问题，所以才要规定max。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">为什么newCacheThreadPool可以实现无限线程，原因是core=<span class="number">0</span>，新来的任务直接进入queue，然后直接新建线程执行。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>SynchronousQueue内部没有容器，一个生产线程，当它生产产品（即put的时候），如果当前没有人想要消费产品(即当前没有线程执行take)，此生产线程必须阻塞，等待一个消费线程调用take操作，take操作将会唤醒该生产线程，同时消费线程会获取生产线程的产品（即数据传递），这样的一个过程称为一次配对过程(当然也可以先take后put,原理是一样的)。</p>
<p>具体当有空闲线程了，此时队列中的任务是怎么提交给现成的呢？</p>
<p>这是ThreadPoolExecutor实现的，其实是调了非阻塞的offer，交给空闲线程，没有空闲就要新建。</p>
</blockquote>
<hr>
<hr>
<p>其实线程池的参数的设置还和系统其他硬件资源，甚至是QPS都能扯上关系</p>
<p>QPS也就是每秒能够处理的请求数，计算时QPS=线程数*（每秒能执行的操作数）</p>
<p>假如一次请求执行的时间是100ms，那么单个请求QPS就是1000/100=10，所以如果线程数=10，那么总QPS=100</p>
<p><font color = "blue">假如此时说规定DB最大QPS是20，那么线程数也就缩小到原来的一半，这样计算适用于QPS有限制的场景</font></p>


        <hr>
        <!-- Pager -->
        <ul class="pager">
          
          <li class="previous">
            <a href="/cn/2022-03-10-SSM项目Curd过程中出现的问题/" data-toggle="tooltip" data-placement="top" title="SSM医疗后台Curd过程中出现的问题">&larr; Previous Post</a>
          </li>
          
          
          <li class="next">
            <a href="/cn/Java 多线程/" data-toggle="tooltip" data-placement="top" title="Java 多线程中的线程池">Next Post &rarr;</a>
          </li>
          
        </ul>

        
        <!-- tip start -->
        <!-- tip -->
<!-- tip start -->
<div class="tip">
  <p>
    
      如果您喜欢此博客或发现它对您有用，则欢迎对此发表评论。 也欢迎您共享此博客，以便更多人可以参与。 如果博客中使用的图像侵犯了您的版权，请与作者联系以将其删除。 谢谢 ！
    
  </p>
</div>
<!-- tip end -->

        <!-- tip end -->
        

        
        <!-- Sharing Srtart -->
        <!-- Social Social Share Post -->
<!-- Docs:https://github.com/overtrue/share.js -->

<div class="social-share" data-initialized="true" data-disabled="tencent ,douban ,qzone ,linkedin ,facebook ,google ,diandian" data-wechat-qrcode-helper="" align="center">
  <ul class="list-inline text-center social-share-ul">
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-twitter">
        <i class="fa fa-twitter fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a class="social-share-icon icon-wechat">
        <i class="fa fa-weixin fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-weibo">
        <i class="fa fa-weibo fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon icon-qq">
        <i class="fa fa-qq fa-1x" aria-hidden="true"></i>
      </a>
    </li>
    <li class="social-share-li">
      <a target="_blank" class="social-share-icon" href="mailto:?subject=近期对多线程的深入理解&body=Hi,I found this website and thought you might like it http://example.com/cn/近期对多线程的深入理解/">
        <i class="fa fa-envelope fa-1x" aria-hidden="true"></i>
      </a>
    </li>
  </ul>
</div>

<!-- css & js -->
<!-- <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css"> -->
<script defer="defer" async="true" src="https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>

        <!-- Sharing End -->
        
        <hr>

        <!-- comments start -->
        <!-- 1. gitalk comment -->


<!-- 2. gitment comment -->

  <!-- gitment start -->
  <!-- Docs:https://github.com/imsun/gitment -->

  <div id="blog_comments"></div>
  <!-- <link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"> <script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script> -->

  <script src="https://cdn.jsdelivr.net/gh/theme-next/theme-next-gitment@1/gitment.browser.js"></script>

  <script>
    const myTheme = {
      render(state, instance) {
        const container = document.createElement('div')
        container.lang = "en-US"
        container.className = 'gitment-container gitment-root-container'

        // your custom component
        container.appendChild(instance.renderSomething(state, instance))
        container.appendChild(instance.renderHeader(state, instance))
        container.appendChild(instance.renderEditor(state, instance))
        container.appendChild(instance.renderComments(state, instance))
        container.appendChild(instance.renderFooter(state, instance))
        return container
      },
      renderSomething(state, instance) {
        const container = document.createElement('div')
        container.lang = "en-US"
        container.className = 'hello_visitor'
        if (state.user.login) {
          container.innerText = `Hello ${state.user.login}, Welcome to comment system`
        }
        return container
      }
    }

    const gitment = new Gitment({
      id: 'Wed Aug 19 2020 02:34:17 GMT+0800', // optional
      owner: 'SFHJavaer',
      repo: 'SFHJavaer',
      oauth: {
        client_id: 'beed42a108cae24cf4a7',
        client_secret: '8576330fb6385d5fd5dc0c2770869a07310aa3e5'
      },
      desc: '',
      perPage: '10',
      maxCommentHeight: '250',
      theme: myTheme,
      // ... For more available options, check out the documentation below
    })

    gitment.render('blog_comments')
    // or gitment.render(document.getElementById('comments')) or document.body.appendChild(gitment.render())
  </script>

  <!-- gitment end -->


<!-- 3. disqus comment -->


        <!-- comments end -->
        <hr>

      </div>

      <!-- Catalog: Tabe of Content -->
      <!-- Table of Contents -->

    
      <aside id="sidebar">
        <div id="toc" class="toc-article">
        <strong class="toc-title">目录</strong>
        
          <ol class="toc-nav"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E6%9C%80%E8%BF%91%E9%87%8D%E6%96%B0%E6%B7%B1%E5%85%A5%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98%E8%BF%9B%E8%A1%8C%E4%BA%86%E6%B7%B1%E5%85%A5%EF%BC%8C%E5%9C%A8%E6%AD%BB%E9%94%81%E3%80%81%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E3%80%81Guava%E3%80%81%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BB%A5%E5%8F%8A%E9%98%9F%E5%88%97%E5%8F%88%E6%9C%89%E4%BA%86%E6%B7%B1%E5%85%A5%E7%9A%84%E6%80%9D%E8%80%83%E3%80%82"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">最近重新深入多线程中的细节问题进行了深入，在死锁、终止线程、Guava、线程池以及队列又有了深入的思考。</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%AF%B9%E9%98%BB%E5%A1%9E%E6%80%81%E5%8D%B3blocked%E7%8A%B6%E6%80%81%E8%BF%9B%E8%A1%8C%E7%BB%86%E5%88%86%EF%BC%9A"><span class="toc-nav-number"></span> <span class="toc-nav-text">对阻塞态即blocked状态进行细分：</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E8%80%8Cyield%E5%92%8C%E9%98%BB%E5%A1%9E%E7%8A%B6%E6%80%81%E6%97%A0%E5%85%B3%EF%BC%8C%E4%BC%9A%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E5%88%B0%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81%E7%AD%89%E5%BE%85CPU%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%88%86%E9%85%8D"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">而yield和阻塞状态无关，会直接进入到就绪状态等待CPU时间片的分配</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#join%E9%87%8A%E6%94%BE%E9%94%81%E5%92%8C%E5%8F%AF%E8%83%BD%E4%BA%A7%E7%94%9F%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98%E8%AF%A6%E8%A7%A3"><span class="toc-nav-number"></span> <span class="toc-nav-text">join释放锁和可能产生的死锁问题详解</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B%EF%BC%9A"><span class="toc-nav-number"></span> <span class="toc-nav-text">产生死锁示例：</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E8%BF%99%E6%A0%B7%E4%BC%9A%E6%8A%8A%E9%94%81%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E8%BF%9B%E8%A1%8C%E9%87%8A%E6%94%BE%EF%BC%8C%E5%BD%93%E7%84%B6%E4%B8%8D%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%BB%E9%94%81%E4%BA%86%EF%BC%8C%E9%87%8D%E7%82%B9%E5%9C%A8%E4%BA%8E%E6%90%9E%E6%B8%85%E6%A5%9A%E9%94%81%E7%9A%84%E5%88%B0%E5%BA%95%E6%98%AF%E8%B0%81"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">这样会把锁的线程对象进行释放，当然不会产生死锁了，重点在于搞清楚锁的到底是谁</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#PS%EF%BC%9A%E4%BD%86%E6%98%AFjoin%E9%87%8A%E6%94%BE%E9%94%81%E5%92%8Cwait%E9%87%8A%E6%94%BE%E9%94%81%E6%98%AF%E6%9C%89%E5%8C%BA%E5%88%AB%E7%9A%84%EF%BC%8Cwait%E9%9C%80%E8%A6%81%E9%87%8D%E6%96%B0%E6%8A%A2%E5%8D%A0%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%8C%E4%BD%86%E6%98%AFjoin%E7%AD%89%E5%BE%85%E8%B0%83%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%BB%A7%E7%BB%AD%E6%89%A7%E8%A1%8C%E4%BA%86%EF%BC%8C%E5%8E%9F%E5%9B%A0%E5%B0%B1%E6%98%AFjoin%E9%87%8A%E6%94%BE%E7%9A%84%E4%B8%8D%E6%98%AF%E8%B0%83%E7%94%A8%E7%9A%84Object%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%81%EF%BC%8Csynchronized%E9%94%81%E7%9A%84%E4%B8%80%E8%88%AC%E6%98%AFObject%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%80%8Cjoin%E6%BA%90%E7%A0%81%E4%B8%AD%E7%94%A8%E7%9A%84%E6%98%AFthis-wait%EF%BC%8C%E8%80%8Cjoin%E5%8F%AA%E8%83%BD%E7%BA%BF%E7%A8%8B%E5%AF%B9%E8%B1%A1%E5%8E%BB%E8%B0%83%EF%BC%8C%E6%89%80%E4%BB%A5%E9%87%8A%E6%94%BE%E7%9A%84%E6%98%AFthread1%E7%9A%84%E9%94%81"><span class="toc-nav-number"></span> <span class="toc-nav-text">PS：但是join释放锁和wait释放锁是有区别的，wait需要重新抢占对象的锁，但是join等待调用线程执行完之后就可以继续执行了，原因就是join释放的不是调用的Object对象的锁，synchronized锁的一般是Object对象，而join源码中用的是this.wait，而join只能线程对象去调，所以释放的是thread1的锁</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-nav-number"></span> <span class="toc-nav-text">如下：</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#Thread%E5%A6%82%E4%BD%95%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B"><span class="toc-nav-number"></span> <span class="toc-nav-text">Thread如何终止线程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#1-%E6%AD%A3%E5%B8%B8%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8C%E5%BD%93%E7%84%B6%E7%AD%89%E7%BA%BF%E7%A8%8B%E7%9A%84run%E6%89%A7%E8%A1%8C%E4%BD%93%E6%89%A7%E8%A1%8C%E5%AE%8C%E4%B9%8B%E5%90%8E%E7%BA%BF%E7%A8%8B%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%BB%88%E6%AD%A2"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">1.正常情况下，当然等线程的run执行体执行完之后线程会自动终止</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#2-stop-%E6%96%B9%E6%B3%95"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">2.stop()方法</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#font-color-blue-PS%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95-font"><span class="toc-nav-number"></span> <span class="toc-nav-text">PS：线程的管理方法</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#3-%E6%AF%94%E8%BE%83%E5%AE%89%E5%85%A8%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%81%9C%E6%AD%A2%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%B8%AD%E6%96%AD%EF%BC%8Cinterrupt-%EF%BC%8C%E6%98%AF%E9%9D%9E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">3.比较安全的线程停止方式：中断，interrupt()，是非静态方法</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%B1%9E%E4%BA%8E%E4%B8%BB%E5%8A%A8%E5%BC%8F%E4%B8%AD%E6%96%AD%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E4%BC%9A%E8%AE%BE%E7%BD%AE%E4%B8%80%E4%B8%AA%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%8C%E7%BA%BF%E7%A8%8B%E4%BC%9A%E4%B8%8D%E6%96%AD%E8%BD%AE%E8%AF%A2%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%8C%E5%BD%93%E6%A0%87%E5%BF%97%E4%BD%8D%E4%B8%BA%E7%9C%9F%E6%97%B6%EF%BC%8C%E4%BC%9A%E5%9C%A8%E6%9C%80%E8%BF%91%E7%9A%84%E4%B8%80%E4%B8%AA%E5%AE%89%E5%85%A8%E7%82%B9%E6%8C%82%E8%B5%B7%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-nav-number">2.</span> <span class="toc-nav-text">属于主动式中断，也就是会设置一个标志位，线程会不断轮询标志位，当标志位为真时，会在最近的一个安全点挂起线程。</span></a></li><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E7%9A%84%E4%B8%80%E7%82%B9%E7%9A%84%E6%98%AF%EF%BC%9Ainterrupt-%E6%96%B9%E6%B3%95%E5%B9%B6%E4%B8%8D%E5%83%8F%E5%9C%A8-for-%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5%E4%B8%AD%E4%BD%BF%E7%94%A8-break-%E8%AF%AD%E5%8F%A5%E9%82%A3%E6%A0%B7%E5%B9%B2%E8%84%86%EF%BC%8C%E9%A9%AC%E4%B8%8A%E5%B0%B1%E5%81%9C%E6%AD%A2%E5%BE%AA%E7%8E%AF%E3%80%82%E8%B0%83%E7%94%A8-interrupt-%E6%96%B9%E6%B3%95%E4%BB%85%E4%BB%85%E6%98%AF%E5%9C%A8%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%93%E4%B8%80%E4%B8%AA%E5%81%9C%E6%AD%A2%E7%9A%84%E6%A0%87%E8%AE%B0%EF%BC%8C%E5%B9%B6%E4%B8%8D%E6%98%AF%E7%9C%9F%E7%9A%84%E5%81%9C%E6%AD%A2%E7%BA%BF%E7%A8%8B%E3%80%82"><span class="toc-nav-number">3.</span> <span class="toc-nav-text">需要明确的一点的是：interrupt() 方法并不像在 for 循环语句中使用 break 语句那样干脆，马上就停止循环。调用 interrupt() 方法仅仅是在当前线程中打一个停止的标记，并不是真的停止线程。</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8E%A8%E8%8D%90%E7%94%A8%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AE%9A%E4%B9%89%E7%9A%84%E5%85%A8%E5%B1%80flag%E5%8E%BB%E5%88%A4%E6%96%AD%EF%BC%9F"><span class="toc-nav-number"></span> <span class="toc-nav-text">为什么推荐用自己的定义的全局flag去判断？</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%8E%9F%E5%9B%A0%E6%98%AF%E8%87%AA%E5%B7%B1%E5%AE%9A%E4%B9%89%E7%9A%84%E8%8C%83%E5%9B%B4%E6%9B%B4%E5%B9%BF%EF%BC%8C%E8%80%8C%E5%88%A4%E6%96%AD%E7%BA%BF%E7%A8%8B%E8%87%AA%E5%B8%A6%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D%E6%AF%94%E8%BE%83%E9%BA%BB%E7%83%A6%E8%A6%81%E8%B0%83%E6%96%B9%E6%B3%95%EF%BC%8Cflag%E4%B9%9F%E5%8F%AF%E4%BB%A5%E5%BA%94%E7%94%A8%E5%88%B0%E4%B8%AD%E6%96%AD%E9%98%BB%E5%A1%9E%E7%BA%BF%E7%A8%8B%E4%B8%8A%EF%BC%8C%E5%A6%82main%E7%BA%BF%E7%A8%8B%E8%B0%83%E7%94%A8thread01-interrupt-%EF%BC%8C%E8%80%8Cthread01%E7%9A%84run%E4%B8%AD%E4%B8%80%E7%9B%B4%E6%98%AFsleep%E7%9A%84%EF%BC%8Csleep%E6%98%AF%E4%B8%8D%E8%83%BD%E5%88%A4%E6%96%ADfalg%E7%9A%84%EF%BC%8Cthread01%E4%BE%9D%E9%9D%A0%E5%88%A4%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D%E6%9D%A5%E5%86%B3%E5%AE%9A%E6%98%AF%E4%B8%8D%E6%98%AF%E5%81%9C%E6%AD%A2%E8%87%AA%E5%B7%B1%EF%BC%8C%E6%89%80%E4%BB%A5%E6%8E%89%E4%BA%86interrupt%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%8A%9B%E4%BA%86Exception%E5%B0%B1%E4%BC%9A%E5%BC%BA%E8%A1%8C%E4%B8%AD%E6%96%ADsleep%EF%BC%8C%E6%89%80%E4%BB%A5%E4%BC%9A%E5%88%B0thread01%E7%9A%84catch%E4%B8%AD%E5%88%A4%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E6%A0%87%E5%BF%97%E4%BD%8D%E6%98%AFtrue%EF%BC%8C%E5%B0%B1%E5%8F%AF%E4%BB%A5%E6%94%BE%E5%BF%83%E4%B8%AD%E6%96%AD%E8%87%AA%E5%B7%B1%E4%BA%86%E3%80%82%E5%8F%AF%E4%BB%A5%E7%94%A8isInterrupted%E5%8E%BB%E5%88%A4%E6%96%AD%E6%98%AF%E4%B8%8D%E6%98%AF%E8%A2%AB%E4%B8%AD%E6%96%AD%E4%BA%86%EF%BC%8C%E5%8E%9F%E7%90%86%E6%98%AF%E9%80%9A%E8%BF%87%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E6%9C%89%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E8%AE%BE%E7%BD%AE%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%87%AA%E5%B7%B1%E4%B8%8D%E8%AE%BE%E7%BD%AE%E6%A0%87%E5%BF%97%E4%BD%8D%E7%9A%84%E8%AF%9D%EF%BC%8C%E5%B0%B1%E7%94%A8isInterrupted%E5%88%A4%E6%96%AD%E6%A0%87%E5%BF%97%E4%BD%8D%E6%98%AF%E4%B8%8D%E6%98%AFtrue%EF%BC%8C%E6%B3%A8%E6%84%8F%E8%BF%99%E4%B8%AAinterrupt-%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%89%A7%E8%A1%8C%E4%BC%9A%E6%8A%8A%E6%A0%87%E5%BF%97%E4%BD%8D%E5%8F%98%E4%B8%BAtrue%EF%BC%8C%E5%86%8D%E6%AC%A1%E8%B0%83%E7%94%A8%E7%9A%84%E8%AF%9D%E5%B0%B1%E5%8F%98%E6%88%90false%E4%BA%86%E3%80%82"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">原因是自己定义的范围更广，而判断线程自带的标志位比较麻烦要调方法，flag也可以应用到中断阻塞线程上，如main线程调用thread01.interrupt()，而thread01的run中一直是sleep的，sleep是不能判断falg的，thread01依靠判断标志位来决定是不是停止自己，所以掉了interrupt之后，抛了Exception就会强行中断sleep，所以会到thread01的catch中判断标志位，然后标志位是true，就可以放心中断自己了。可以用isInterrupted去判断是不是被中断了，原理是通过检查是否有标志位的设置，如果自己不设置标志位的话，就用isInterrupted判断标志位是不是true，注意这个interrupt()第一次执行会把标志位变为true，再次调用的话就变成false了。</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-nav-number"></span> <span class="toc-nav-text">守护线程</span></a></li><li class="toc-nav-item toc-nav-level-4"><a class="toc-nav-link" href="#%E5%85%B3%E4%BA%8EGuava%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-nav-number"></span> <span class="toc-nav-text">关于Guava中的多线程</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%EF%BC%9A%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%A4%9A%E4%B8%AA%E7%BA%BF%E7%A8%8B%E5%91%BD%E5%90%8D%E9%83%BD%E6%98%AFThread-01%E7%AD%89%E7%AD%89%E7%94%B1%E7%B3%BB%E7%BB%9F%E5%88%86%E6%89%B9%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E6%9C%89%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%8C%E6%AF%8F%E4%B8%AA%E4%BB%BB%E5%8A%A1%E6%9C%89%E5%90%84%E8%87%AA%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9C%A8%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C%E6%89%93%E5%8D%B0%E6%97%A5%E5%BF%97%E6%97%B6%EF%BC%8C%E6%88%91%E4%BB%AC%E6%98%AF%E6%97%A0%E6%B3%95%E5%88%86%E6%B8%85%E6%A5%9A%E6%89%A7%E8%A1%8C%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%93%AA%E4%B8%80%E4%B8%AA%E6%B1%A0%E7%9A%84%EF%BC%8C%E5%BD%93%E7%84%B6%E5%9C%A8%E6%89%A7%E8%A1%8C%E5%8D%95%E4%B8%AA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%97%B6%E5%80%99%EF%BC%8C%E6%88%91%E4%BB%AC%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Thread-setName%E6%9D%A5%E6%8C%87%E5%AE%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8D%E7%A7%B0%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9C%A8Java%E4%B8%AD%E6%B2%A1%E6%9C%89%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E5%8F%AF%E4%BE%9B%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%BA%BF%E7%A8%8B%E5%91%BD%E5%90%8D%E7%9A%84%E6%96%B9%E5%BC%8F%E3%80%82"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">在多线程线程池中：池中的多个线程命名都是Thread-01等等由系统分批，如果我们有多个任务，每个任务有各自执行任务的线程池，那么在任务执行打印日志时，我们是无法分清楚执行线程是属于哪一个池的，当然在执行单个线程的时候，我们可以使用Thread.setName来指定线程的名称，但是在Java中没有提供一个可供修改线程中线程命名的方式。</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E6%89%80%E4%BB%A5Guava%E5%B0%B1%E6%8F%90%E4%BE%9B%E4%BA%86%E8%BF%99%E4%B9%88%E4%B8%80%E7%A7%8D%E9%93%BE%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%96%B9%E5%BC%8F%EF%BC%88%E5%85%B6%E5%AE%9E%E7%9C%8B%E5%AE%98%E6%96%B9%E6%B3%A8%E8%A7%A3%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%98%AF%E5%BB%BA%E9%80%A0%E8%80%85%EF%BC%89%EF%BC%8C%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E7%BA%BF%E7%A8%8B%E7%BB%84%E5%91%BD%E5%90%8D-%E4%BD%8D%E4%BA%8Egcuc%E5%8C%85%E4%B8%AD%EF%BC%9A"><span class="toc-nav-number"></span> <span class="toc-nav-text">所以Guava就提供了这么一种链式编程方式（其实看官方注解可以发现是建造者），可以修改线程组命名,位于gcuc包中：</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%97%AE%E9%A2%98"><span class="toc-nav-number"></span> <span class="toc-nav-text">线程池问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-6"><a class="toc-nav-link" href="#%E9%A6%96%E5%85%88%E8%AF%B4%E4%B8%8B%E8%BF%90%E7%AE%97%E7%B1%BB%E5%9E%8B%EF%BC%9ACPU%E5%AF%86%E9%9B%86%E5%9E%8B%E3%80%81IO%E5%AF%86%E9%9B%86%E5%9E%8B"><span class="toc-nav-number">1.</span> <span class="toc-nav-text">首先说下运算类型：CPU密集型、IO密集型</span></a></li></ol></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%B8%80%E8%88%AC%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A4%A7%E5%B0%8F%EF%BC%88%E6%A0%B8%E5%BF%83%E7%BA%BF%E7%A8%8B%E6%95%B0%EF%BC%89%EF%BC%9FN%E4%BB%A3%E8%A1%A8CPU%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%EF%BC%8C%E6%AD%A3%E5%B8%B8%E8%BF%98%E6%98%AF%E4%B8%80%E4%B8%AA%E6%A0%B8%E5%BF%83%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-nav-number"></span> <span class="toc-nav-text">一般如何设置线程池大小（核心线程数）？N代表CPU的核心数，正常还是一个核心一个线程</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-nav-number"></span> <span class="toc-nav-text">一个问题</span></a><ol class="toc-nav-child"><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%BB%E8%A6%81%E7%94%A8%E5%9C%A8%E8%BF%99%E5%87%A0%E4%B8%AA%E5%9C%B0%E6%96%B9"><span class="toc-nav-number"></span> <span class="toc-nav-text">你的项目中线程池主要用在这几个地方</span></a></li><li class="toc-nav-item toc-nav-level-5"><a class="toc-nav-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E6%94%B9%E6%88%90%E6%99%AE%E9%80%9A%E9%98%9F%E5%88%97%E5%91%A2%EF%BC%9F"><span class="toc-nav-number"></span> <span class="toc-nav-text">能不能改成普通队列呢？</span></a></li></ol></li></ol></li><li class="toc-nav-item toc-nav-level-3"><a class="toc-nav-link" href="#SynchronousQueue"><span class="toc-nav-number"></span> <span class="toc-nav-text">SynchronousQueue</span></a>
        
        </div>
      </aside>
    



      <!-- Sidebar Container -->
      <div class="
                col-lg-8 col-lg-offset-1
                col-md-10 col-md-offset-1
                sidebar-container">

        <!-- Featured Tags -->
        
        <section>
          <!-- no hr -->
          <h5>
            <a href="/tags/">特色标签</a>
          </h5>
          <div class="tags">
            
            <a class="tag" href="/tags/#多线程" title="多线程">多线程</a>
            
          </div>
        </section>
        

        <!-- Friends Blog -->
        
        <hr>
        <h5>链友</h5>
        <ul class="list-inline">

          
          <li>
            <a href="https://SFHJavaer.github.io/" target="_blank">Futari</a>
          </li>
          
          <li>
            <a href="http://beantech.org" target="_blank">Bean Tech</a>
          </li>
          
          <li>
            <a href="http://huangxuan.me" target="_blank">Hux Blog</a>
          </li>
          
          <li>
            <a href="https://hexo.io/" target="_blank">Hexo</a>
          </li>
          
        </ul>
        
      </div>
    </div>
  </div>
</article>



<!-- anchorjs start -->
<!-- async load function -->
<!-- anchor-js, Doc:http://bryanbraun.github.io/anchorjs/ -->
<script type="text/javascript">
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function(e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  };
</script>
<script type="text/javascript">
  //anchor-js, Doc:http://bryanbraun.github.io/anchorjs/
  async ("https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js", function() {
    anchors.options = {
      visible: 'hover',
      placement: 'left',
      // icon: 'ℬ'
      icon: '❡'
    };
    anchors.add().remove('.intro-header h1').remove('.subheading').remove('.sidebar-container h5');
  });
</script>
<style>
  /* place left on bigger screen */
  @media all and (min-width: 800px) {
    .anchorjs-link {
      position: absolute;
      left: -0.75em;
      font-size: 1.1em;
      margin-top: -0.1em;
    }
  }
</style>

<!-- anchorjs end -->



		<!-- Footer (contains ThemeColor、viewer) -->
		<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <ul class="list-inline text-center">
          

          
            <li>
              <a target="_blank" href="https://github.com/SFHJavaer">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://twitter.com/SFHJavaer">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          
            <li>
              <a target="_blank" href="https://www.instagram.com/SFHJavaer">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-instagram fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

          

          

          

          
            <li>
              <a target="_blank" href="http://weibo.com/SFHJavaer">
                <span class="fa-stack fa-lg">
                  <i class="fa fa-circle fa-stack-2x"></i>
                  <i class="fa fa-weibo fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
          

        </ul>
        <p class="copyright text-muted">
          Copyright &copy;
          SFHJavaer
          2025
          <br>
          Theme by
          <a target="_blank" rel="noopener" href="http://beantech.org">BeanTech</a>
          <span style="display: inline-block; margin: 0 5px;">
            <i class="fa fa-heart"></i>
          </span>
          re-Ported by
          <a target="_blank" rel="noopener" href="https://v-vincen.life/">Live My Life</a>
          |
          <iframe style="margin-left: 2px; margin-bottom:-5px;" frameborder="0" scrolling="0" width="91px" height="20px" src="https://ghbtns.com/github-btn.html?user=V-Vincen&repo=V-Vincen.github.io&type=star&count=true"></iframe>
        </p>
      </div>
    </div>
  </div>
</footer>

<a id="rocket" href="#top" class=""></a>


  <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/jquery.min.js"></script>

  <!-- Bootstrap Core JavaScript -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/bootstrap.min.js"></script>

  <!-- Custom Theme JavaScript -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/hux-blog.min.js"></script>

  <!-- catalog -->
  <script async="true" type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/catalog.js"></script>

  <!-- totop(rocket) -->
  <script async="true" type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/totop.js"></script>

  
    <!-- Busuanzi JavaScript -->
    <script async="async" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  

  
    <!-- Scroll start -->
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/scroll.js"></script>
    <!-- Scroll end -->
  

  
    <!-- LangSelect start -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/langselect.js"></script>
    <!-- LangSelect end -->
  

  
    <!-- Mouseclick -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/mouseclick.js"  content='The first step is as good as half over...,Laugh and grow fat...,Man proposes God disposes...,When all else is lost the future still remains...,Wasting time is robbing oneself...,Sharp tools make good work...,Cease to struggle and you cease to live...,A friend in need is a friend indeed...,Faith can move mountains...' color='#9933CC,#339933,#66CCCC,#FF99CC,#CCCCFF,#6666CC,#663399,#66CC99,#FF0033' ></script>
    <!-- Mouseclick -->
  

  
    <!-- ribbon -->
    <script type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/ribbonDynamic.js"></script>
  

  




  <!-- CDN: jsdelivr start -->
  <script async="async" type="text/javascript">
    let imgsUrl = document.getElementsByTagName("img");
    let imgUrl = Array.from(imgsUrl);

    let jsdelivr = "https://cdn.jsdelivr.net/gh/";
    let gh = "SFHJavaer";
    let ghPages = gh + ".github.io";
    let pagePath = "cn/近期对多线程的深入理解/";
    let jsdelivrurl;
    if (pagePath.indexOf("index.html") != -1) {
      jsdelivrurl = jsdelivr + gh + "/" + ghPages;
    } else {
      jsdelivrurl = jsdelivr + gh + "/" + ghPages + "/" + pagePath;
    }
    imgUrl.forEach(item => {
      let oldUrl = item.getAttribute("src");
      let newUrl = oldUrl.replace(oldUrl, jsdelivrurl + oldUrl).replace("..", "");
      item.setAttribute("src", newUrl);
    });
  </script>
  <!-- CDN: jsdelivr end -->



  <!-- viewer start -->
  <!-- viewer start (Picture preview) -->
  
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/viewer/viewer.min.js"></script>
    <script async="async" type="text/javascript" src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/viewer/pic-viewer.js"></script>
  

  <!-- viewer end -->


<script>
  // async load function
  function async (u, c) {
    var d = document,
      t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (c) {
      o.addEventListener('load', function (e) {
        c(null, e);
      }, false);
    }
    s.parentNode.insertBefore(o, s);
  }

  // fastClick.js
  async ("https://cdn.bootcss.com/fastclick/1.0.6/fastclick.min.js", function () {
    var $nav = document.querySelector("nav");
    if ($nav)
      FastClick.attach($nav);
    }
  )
</script>

<!-- Because of the native support for backtick-style fenced code blocks right within the Markdown is landed in Github Pages, From V1.6, There is no need for Highlight.js, so Huxblog drops it officially. -
https://github.com/blog/2100-github-pages-now-faster-and-simpler-with-jekyll-3-0 - https://help.github.com/articles/creating-and-highlighting-code-blocks/ -->
<!-- <script> async ("http://cdn.bootcss.com/highlight.js/8.6/highlight.min.js", function () { hljs.initHighlightingOnLoad(); }) </script> <link href="http://cdn.bootcss.com/highlight.js/8.6/styles/github.min.css" rel="stylesheet"> -->

<!-- jquery.tagcloud.js -->
<!-- <script> // only load tagcloud.js in tag.html if ($('#tag_cloud').length !== 0) { async ("http://example.com/js/jquery.tagcloud.js", function () { $.fn.tagcloud.defaults = { // size: { start: 1, end: 1, unit: 'em' }, color: {
start: '#bbbbee', end: '#0085a1' } }; $('#tag_cloud a').tagcloud(); }) } </script> -->


		<!-- Search -->
		
		<div class="popup search-popup local-search-popup">
  <span class="popup-btn-close">
    ESC
  </span>
  <div class="container">
    <div class="row">
      <!-- <div class="col-md-9 col-md-offset-1"> -->
      <div class="col-lg-9 col-lg-offset-1 col-md-10 col-md-offset-1 local-search-content">

        <div class="local-search-header clearfix">

          <div class="local-search-input-wrapper">
            <span class="search-icon">
              <i class="fa fa-search fa-lg" style="margin: 25px 10px 25px 20px;"></i>
            </span>
            <input autocomplete="off" placeholder="搜索..." type="text" id="local-search-input">
          </div>
        </div>
        <div id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>


  
    <script src="https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io/js/ziploader.js"></script>
  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.json";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    // monitor main search box;
    var onPopupClose = function (e) {
      $('.popup').fadeOut(300);
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $('.popup').fadeIn(300);
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }
    // get search zip version
    $.get('/searchVersion.json?t=' + (+new Date()), function (res) {
      if (localStorage.getItem('searchVersion') !== res) {
        localStorage.setItem('searchVersion', res);
        initSearchJson();
      }
    });

    function initSearchJson() {
      initLoad(['/search.flv'], {
        loadOptions: {
          success: function (obj) {
            localStorage.setItem('searchJson', obj['search.json'])
          },
          error: function (e) {
            return console.log(e)
          }
        },
        returnOptions: {
          'json': TYPE_TEXT
        },
        mimeOptions: {
          'json': 'application/json'
        }
      })
    }
    // search function;
    var searchFunc = function (search_id, content_id) {
      'use strict';
      isfetched = true;
      var datas = JSON.parse(localStorage.getItem('searchJson'));
      // console.log(search_id)
      var input = document.getElementById(search_id);
      var resultContent = document.getElementById(content_id);
      var inputEventFunction = function () {
        var searchText = input.value.trim().toLowerCase();
        var keywords = searchText.split(/[\s\-]+/);
        if (keywords.length > 1) {
          keywords.push(searchText);
        }
        var resultItems = [];
        if (searchText.length > 0) {
          // perform local searching
          datas.forEach(function (data) {
            var isMatch = false;
            var hitCount = 0;
            var searchTextCount = 0;
            var title = data.title
              ? data.title.trim()
              : '';
            var titleInLowerCase = title.toLowerCase();
            var content = data.content
              ? data.content.trim().replace(/<[^>]+>/g, "")
              : '';
            var contentInLowerCase = content.toLowerCase();
            var articleUrl = decodeURIComponent(data.url);

            var date = data.date;
            var dateTime = date.replace(/T/, " ").replace(/.000Z/, "");
            var imgUrl = data.header_img;
            
              imgUrl = 'https://cdn.jsdelivr.net/gh/SFHJavaer/SFHJavaer.github.io' + imgUrl;
            


            var indexOfTitle = [];
            var indexOfContent = [];
            // only match articles with not empty titles
            keywords.forEach(function (keyword) {
              function getIndexByWord(word, text, caseSensitive) {
                var wordLen = word.length;
                if (wordLen === 0) {
                  return [];
                }
                var startPosition = 0,
                  position = [],
                  index = [];
                if (!caseSensitive) {
                  text = text.toLowerCase();
                  word = word.toLowerCase();
                }
                while ((position = text.indexOf(word, startPosition)) > -1) {
                  index.push({position: position, word: word});
                  startPosition = position + wordLen;
                }
                return index;
              }
              indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
              indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
            });
            if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
              isMatch = true;
              hitCount = indexOfTitle.length + indexOfContent.length;
            }
            // show search results
            if (isMatch) {
              // sort index by position of keyword
              [indexOfTitle, indexOfContent].forEach(function (index) {
                index.sort(function (itemLeft, itemRight) {
                  if (itemRight.position !== itemLeft.position) {
                    return itemRight.position - itemLeft.position;
                  } else {
                    return itemLeft.word.length - itemRight.word.length;
                  }
                });
              });
              // merge hits into slices
              function mergeIntoSlice(text, start, end, index) {
                var item = index[index.length - 1];
                var position = item.position;
                var word = item.word;
                var hits = [];
                var searchTextCountInSlice = 0;
                while (position + word.length <= end && index.length != 0) {
                  if (word === searchText) {
                    searchTextCountInSlice++;
                  }
                  hits.push({position: position, length: word.length});
                  var wordEnd = position + word.length;
                  // move to next position of hit
                  index.pop();
                  while (index.length != 0) {
                    item = index[index.length - 1];
                    position = item.position;
                    word = item.word;
                    if (wordEnd > position) {
                      index.pop();
                    } else {
                      break;
                    }
                  }
                }
                searchTextCount += searchTextCountInSlice;
                return {hits: hits, start: start, end: end, searchTextCount: searchTextCountInSlice};
              }
              var slicesOfTitle = [];
              if (indexOfTitle.length != 0) {
                slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
              }
              var slicesOfContent = [];
              while (indexOfContent.length != 0) {
                var item = indexOfContent[indexOfContent.length - 1];
                var position = item.position;
                var word = item.word;
                // cut out 100 characters
                var start = position - 20;
                var end = position + 80;
                if (start < 0) {
                  start = 0;
                }
                if (end < position + word.length) {
                  end = position + word.length;
                }
                if (end > content.length) {
                  end = content.length;
                }
                slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
              }
              // sort slices in content by search text's count and hits' count
              slicesOfContent.sort(function (sliceLeft, sliceRight) {
                if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                  return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                  return sliceRight.hits.length - sliceLeft.hits.length;
                } else {
                  return sliceLeft.start - sliceRight.start;
                }
              });
              // select top N slices in content
              var upperBound = parseInt('1');
              if (upperBound >= 0) {
                slicesOfContent = slicesOfContent.slice(0, upperBound);
              }
              // highlight title and content
              function highlightKeyword(text, slice) {
                var result = '';
                var prevEnd = slice.start;
                slice.hits.forEach(function (hit) {
                  result += text.substring(prevEnd, hit.position);
                  var end = hit.position + hit.length;
                  result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                  prevEnd = end;
                });
                result += text.substring(prevEnd, slice.end);
                return result;
              }
              var resultItem = '';

              // if (slicesOfTitle.length != 0) {   resultItem += "<li><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>"; } else {   resultItem += "<li><a target='_blank' href='" +
              // articleUrl + "' class='search-result-title'>" + title + "</a>"; } slicesOfContent.forEach(function (slice) {   resultItem += "<a target='_blank' href='" + articleUrl + "'><p class=\"search-result\">" + highlightKeyword(content, slice) +
              // "...</p></a>"; }); resultItem += "</li>";

              if (slicesOfTitle.length != 0) {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</div><time class='search-result-date'>" + dateTime + "</time>";
              } else {
                resultItem += "<a target='_blank' href='" + articleUrl + "' class='search-result'><div class='search-result-left'><div class='search-result-title'>" + title + "</div><time class='search-result-date'>" + dateTime + "</time>";
              }
              slicesOfContent.forEach(function (slice) {
                resultItem += "<p class=\"search-result-content\">" + highlightKeyword(content, slice) + "...</p>";
              });
              resultItem += "</div><div class='search-result-right'><img class='media-image' src='" + imgUrl + "' width='64px' height='48px'></img></div></a>";

              resultItems.push({item: resultItem, searchTextCount: searchTextCount, hitCount: hitCount, id: resultItems.length});
            }
          })
        };

        if (keywords.length === 1 && keywords[0] === "") {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else if (resultItems.length === 0) {
          resultContent.innerHTML = '<div id="no-result"></div>'
        } else {
          resultItems.sort(function (resultLeft, resultRight) {
            if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
              return resultRight.searchTextCount - resultLeft.searchTextCount;
            } else if (resultLeft.hitCount !== resultRight.hitCount) {
              return resultRight.hitCount - resultLeft.hitCount;
            } else {
              return resultRight.id - resultLeft.id;
            }
          });
          var searchResultList = '<div class=\"search-result-list\">';
          resultItems.forEach(function (result) {
            searchResultList += result.item;
          })
          searchResultList += "</div>";
          resultContent.innerHTML = searchResultList;
        }
      }
      if ('auto' === 'auto') {
        input.addEventListener('input', inputEventFunction);
      } else {
        $('.search-icon').click(inputEventFunction);
        input.addEventListener('keypress', function (event) {
          if (event.keyCode === 13) {
            inputEventFunction();
          }
        });
      }
      // remove loading animation
      $('body').css('overflow', '');
      proceedsearch();
    }
    // handle and trigger popup window;
    $('.popup-trigger').click(function (e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc('local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });
    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function (e) {
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });

    document.addEventListener('mouseup', (e) => {
      var _con = document.querySelector(".local-search-content");
      if (_con) {
        if (!_con.contains(e.target)) {
          onPopupClose();
        }
      }
    });
  </script>


		
	<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
</body>
</html>
